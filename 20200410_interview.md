## Java 基础

### HashMap 底层实现
> HashMap 底层是一个数组，有元素需要插入时，会通过调用`hashCode()`方法，计算出元素的 hash 值，从而将元素填入对应位置；
> 数组里的元素可能是null（key && value）,可能是单个对象（该对象也可能是null）；
> 当发生hash碰撞时，碰撞元素加入到对应数组位置的已有元素后面，形成单链表；
> 在 Java 1.8 之后，如果链表长度超过一定阈值（8）时，将链表转换为红黑树

### Java 1.7 到 Java 1.8 HashMap 改进
> Java 1.7 中，`HashMap` 使用 `bucket` + `LinkedList` 实现，同一  hash 值的元素都存在同一个`bucket`里，当 hash 值相同的元素太多时，查找效率较低；Java 1.8 中，`HashMap` 使用 `bucket` + `LinkedList` + 红黑树 实现，链表长度超过一定阈值（8）时，将链表转换为红黑树，大大减少查找时间

### HashMap的扩容机制
> 当 HashMap 中的元素越来越多的时候，碰撞的几率急速升高，为了提高查询效率，需要对数组进行扩容。**扩容中最耗性能的一点是：原数组中的数据必须重新计算位置并放到新数组中**。对应的方法名叫`resize()`
> 扩容时机：当 HashMap 元素超过 数组大小 x LoadFactor 时。LoadFactor（扩容因子）默认值为0.75。也就是说，默认情况下，当元素超过 16 x 0.75 = 12 时，需要将数组扩大一倍 16 x 2 = 32，然后调用`resize()`。注意**扩容因子是判断需不需要扩容，数组扩容时每次都是扩大一倍**

### 抽象类/接口的区别
> Java中抽象类需要用`extends`关键字继承；接口使用`implements` 来实现
> 抽象类可以有构造函数，接口不能有
> Java单继承，只能继承一个抽象类，接口可以实现任意个
> 接口中的方法默认使用`public`修饰，抽象类可以是任意修饰符

### 泛型
- 泛型在 Java 1.5 之后引入，使容器类的灵活性和复用性增强
- 泛型可以加在类/接口/方法上，类型参数只可能是对象类型（简单类型不可）
- **泛型擦除** Type Erasure Java在编译期后，字节码文件中类型信息被擦除，变成原生类型

### String对象相关

`String` 字符串的直接操作类。每次赋值都会新建一个对象
`StringBuilder` 字符串的构建类，可以在原有对象基础上操作。非线程安全
`StringBuffer` 字符串的构建类，可以在原有对象基础上操作。线程安全

> 一般来说，**非线程安全的操作比线程安全的操作效率要高**

### 设计模式 分类（常见的）
- 创建型设计模式
	- 工厂模式
	- 抽象工厂模式
	- 单例模式
	- 建造者模式
- 结构型设计模式
	- 适配器模式
	- 组合模式
	- 装饰器模式‘
	- 外观模式
	- 代理模式
- 行为型设计模式
	- 责任链模式
	- 命令模式
	- 解释器模式
	- 迭代器模式
	- 中介者模式
	- 观察者模式
	- 策略模式
	- 访问者模式
	- 模板模式

### 设计模式六大原则
- 开闭原则（对扩展开放，对修改关闭）
- 里氏代换原则（子类一定可以代替基类）
- 依赖倒置原则（针对接口编程，依赖抽象）
- 迪米特法则（模块解耦）
- 接口隔离原则（使用多个隔离的接口）
- 合成复用原则（尽量使用组合/聚合的方式，而非继承）
	
## 线程池

参见 线程池.md

## Kotlin 基础

**let run apply also 之间的区别？**

```kotlin
fun <T, R> T.let(f: (T) -> R): R = f(this)
```
let 将当前对象作为闭包参数`it`，返回**闭包中最后一行的值**
```kotlin
fun <T, R> T.run(f: T.() -> R): R = f()
```
run 在闭包中以`this`作为参数，返回**闭包中最后一行的值**
```kotlin
fun <T> T.apply(f: T.() -> Unit): T { 
	f() 
	return this 
}
```
apply 在闭包中以`this`作为参数，返回**对象本身**
```kotlin
public inline fun <T> T.also(block: (T) -> Unit): T { 
	block(this)
	return this 
}
```
also 将当前对象作为闭包参数`it`，返回**对象本身**

## Android 基础

RxJava 线程切换原理

SpraseArray

自定义View

ARouter 原理

如何自学 Android 开发？ - 奶盖的回答 - 知乎
https://www.zhihu.com/question/26417244/answer/1191786771

HTTPS 证书
https://www.jianshu.com/p/f5172daebd70


