# 腾讯一面（电话）

## 自我介绍

> 略过

## 项目里边有技术挑战的点，具体描述一下

> 可以从项目的渐进式组件化展开说

刚进项目组时，整个应用架构是单一工程模式；随着业务逐渐增加以及团队规模扩大，导致

- 业务代码增加，维护成本逐渐升高
- 多人协作开发变得越来越复杂，代码规范度变低
- 项目构建变慢，编译时间大大增加，非常耗时

基于此，我们对项目进行了组件化重构，在做这项工作时，我们调研了一些组件化过程中可能会遇到的问题

- 如何实现解耦（基本要求）？
- 如何实现组件的单独调试？
- 如何进行组件之间的通信？
- 如何对组件（自有/第三方）进行管理？
- 如何实现渐进式的组件化？

针对上面的问题，我们经过很长一段时间的探讨，在不断地摸索中实现了自己的一套解决方案，具体实施如下

- **解耦** 主要是针对代码解耦和功能解耦两个维度
  - 代码解耦 采用MVP架构，业务与视图隔离，通过Present控制逻辑；后期引入 ViewModel + LiveCycle 使用MVVM架构，进一步简化代码逻辑
  - 功能解耦 即对组件进行划分；基础组件（网络/路由/打点）提供基础服务，不带业务，而且相互隔离，不允许互相引用；业务组件（行情/新闻/研报）提供对业务的封装，使用基础服务，相互之间通过路由等功能提供服务；顶层为壳App，提供运行载体
- **单独调试** 有两种方式，一种是通过对gradle进行配置，project syn动态改变module模式（application/library）;  第二种是对组件分别建立project直接隔离，每个project都对应一个application模块，集成时通过SDK的形式进行引用（jcenter/artifactory）
- **组件通信** 分为组件跳转和广播通信两类
  - 对于组件跳转，通过选型比较，引入ARouter路由框架，能解决的问题有
    - 所有跳转通过URL，没有类依赖，实现解耦
    - 提供了良好的AOP支持，灵活控制跳转前后的过程
    - 提供Service接口，能将逻辑声明为服务，在调用组件中执行，在被调用组件中实现
    - 提供灵活的降级策略，路由丢失时能提供统一/单独的处理模式
  - 对于广播通信，采用EventBus框架实现解耦
- **组件管理** 对自有组件，通过gradle配置脚本，将其打包发布成SDK（aar/jar），实现像第三方组件一样地调用方式；然后，新建 versions.gradle 配置文件，对组件版本号进行统一配置和管理
- **渐进式组件化** 项目中的组件化经历了一个渐进的过程
  1. 确定框架。首先将整个项目按照 基础-业务-壳 大致分层，将业务与非业务进行隔离；此时整个项目暂时只有三个 Module，不用拆得很细，但是这步需要占用一定开发周期专门做这件事
  2. 基础库拆分。将不同的功能拆到不同的组件，严格解耦；组件对外暴露API，业务层直接调用
  3. 建立路由库。并为每个业务页面配置路由并修改页面跳转为路由形式；可能修改会有遗漏，等下一步操作
  4. 业务库拆分。将业务库按照功能进行拆分，业务之间的跳转通过路由（上一步遗漏的），业务之间的引用通过服务获取（服务注册在路由库）
  5. 理论上按照上叙逻辑拆分即可，一些老功能不便迁移的，可以暂缓；每个迭代中间花一定时间进行部分迁移工作，循序渐进即可

## 渐进化组件化怎么实现的

>  见上一问

## 为什么选择ARouter（XXX）框架，怎么选型的

1. 基本功能符不符合项目要求
2. 文档是否齐全，是否存在难以解决的问题
3. 维护者是否及时解决反馈问题
4. 代码质量/开发者声誉

## 多进程架构，一般什么情况下用独立进程，有什么好处

好处：

- 分担主进程的内存压力，降低被系统杀死的概率
- 子进程的崩溃不会影响主进程，反之同样如此
- 可以通过互相监听守护实现保活的效果（不建议）

坏处：

- 消耗更多电量，对用户不友好
- 架构变得复杂，进程之间需要通过IPC通信（静态成员/文件/SP无法同步）
- 无法跨进程断点调试

## 进程间通信 Binder机制有什么好处 做了哪些保证安全性的措施

Android中的进程间通信

- **Intent** 指定 action 隐式构造
- **文件/数据库** 一般是 ContentProvider 提供该能力
- **全局广播** 是一种被动的跨进程通信
- **实现AIDL** Android Interface Definition Language 自己通过AIDL实现进程间通信

> `ActivityManagerService` 实现了 `IInterface` 接口，这个接口代表着实现Binder机制的能力
>
> 而四大组件都是通过`ActivityManagerService` 管理，这就意味着Android中的进程间通信**本质上都是基于Binder**

**Binder关键词** C/S  Linux驱动 一次拷贝 内存映射（mmap）用户态 内核态

Binder机制的好处

- **效率高** 一次拷贝 内存映射
- **安全性好** 身份标识 匿名Binder

## 对Handler的理解 Looper死循环会对性能有什么影响

**Handler** 用于线程间通信，是一种异步回调机制，是**Android引入的一种消息传递机制**（并非Java中）其目的是为了解决更新UI过程中多线程并发引起的问题，即在**主线程创建的UI不可以在子线程中直接更新，必须要通过Handler将消息传递到主线程再更新** `sendMessage()` `handlerMessage()`

> Handler 在哪个线程创建，就在哪个线程中处理事件

**Looper** 消息封装的载体，**通过循环接受和分发Message**；每次有消息传递过来，就会取出然后交给Handler处理。一个线程中只能有一个 Looper

**MessageQueue** 消息队列，可以添加并处理消息，由对应的Looper对象创建并管理



简要流程：系统创建主线程 -> 主线程中创建 Looper 对象 -> Looper 对象创建 MessageQueue -> 开启 Looper 循环 -> 创建子线程处理事件并`sendMessage()` -> 主线程中创建 Handler 接受事件 -> 主线程刷新UI



**死循环本身一直运行，但是在MessageQueue中没有消息时，主线程会进入休眠状态，释放CPU资源**。所以主线程的死循环在没有任务时并不会对性能有较大影响

## 子线程的Looper如何实现不同的线程返回不同对象

子线程里一定会有Looper的实例么？

> 答案是否，Thread 在 `package java.lang` 包中，而 Looper 在基于android系统的 `package android.os`包中)，所以二者并没有必然联系；主线程中的Looper是`ActivityThread`创建的

**ThreadLocal** 是一个集合类型的封装类，被定义成静态变量，以当前线程为key，以线程持有的本地对象为value（此处为Looper对象）；每次调用`Looper.myLooper()`时就从`ThreadLocal`中去获取Looper对象，因此可以实现线程与Looper对象的一一对应

## Handler 的内存泄漏

原因：内部类方式声明Handler时，隐式持有外部类的引用；如果在Handler中处理事件时关闭当前页面，由于Handler的持有，GC无法回收当前Activity，造成内存泄漏

解决：将Handler定义成静态内部类，不持有外部类；如果需要外部类的成员对象，则通过弱引用 WeakReference 来包裹该外部类

## 四种引用方式

| 类型                       | 生命周期       | 回收时间   |
| -------------------------- | -------------- | ---------- |
| 强引用（直接声明）         | JVM停止时终止  | 不回收     |
| 软引用（SoftReference）    | 内存不足时终止 | 内存不足时 |
| 弱引用（WeakReference）    | GC后终止       | 下一次GC时 |
| 虚引用（PhantomReference） | 不确定         | 随时       |

## 垃圾回收机制 判断回收

> 参阅资料

## GC ROOT 方法中 ROOT 指的是什么

- 被Jvm栈中引用的对象
- 静态属性/常量引用的对象
- 本地方法栈（Native）引用的对象

## Android App的编译流程

1. 资源文件通过 aapt 工具打包，生成res文件和R.java文件
2. 如果有自定义的.aidl文件，则生成对应的接口文件
3. 通过Java编译器将所有的java类编译成.class文件
4. 通过D8编译器将.class文件编译成.dex字节码文件，如果配置了混淆，则使用R8编译器混淆压缩
5. 通过ApkBuilder将以上文件压缩打包成apk
6. 使用签名工具对apk进行签名，使用对齐工具对apk进行对齐处理

## 编译时资源文件的处理

- assets 和 raw 资源原封不动地打包，其他资源文件会**被编译成二进制的xml文件**
- 除了assets资源之外，其他资源都会被赋予一个资源ID
- 使用aapt工具编译资源，完成后生成一个  R.java 文件和 resources.arsc 文件 ，供运行时索引资源
- 应用程序运行时通过AssetManager/ResourceID/FilePath来访问资源

## APK的签名机制

**签名** 在 apk 中写入一个“指纹”，写入后，apk 发生任何修改，都会导致这个“指纹”无效，从而安装验证无法通过，保证了安全性

**消息摘要** 通过MD5等签名算法，**保证完整性，但不可篡改性无法保证**

**数字签名** 通过非对称加密算法对 apk 生成对应的公钥和私钥，是 **非对称加密和消息摘要** 技术的结合

**数字证书** 通过证书**验证应用身份**，并且**安全地发送数字签名**



Android 中的三种签名方案

- v1  基于 jar 签名 对zip中的每一个文件都进行校验，而不对zip文件本身进行校验，在META-INF中存放签名文件
- v2 Android 7.0 对zip本身进行校验，签名工具会同时使用 v1 和 v2 签名，以便兼容低版本系统
- v3 Android 9.0 使用 **密钥轮替** 以便应用能在更新过程中动态更改密钥

v2 签名方案的好处

- 安全性更高，整个 apk 都不允许被改动
- 验证效率更高，因为不需要解压验证

## Gradle编译优化 体现在哪些步骤

**避免编译不必要的资源** 比如在开发环境时，可以直接指定语言和屏幕密度

```groovy
productFlavors {
    dev {
        resConfigs "cn", "xxhdpi"
    }
}
```

**使用静态依赖** 避免在声明依赖时将版本号写成`xxx:1.+`的形式，省去检查更新的步骤

**为 gradle 增加堆内存**  在项目的 `gradle.properties` 文件中将 `Gradle` 的堆大小设置为 2048 MB

```groovy
org.gradle.jvmargs = -Xmx2048m
```

**使用远程主机编译** 目前暂未使用

## Java多线程的问题

> 参阅资料

##  多线程操作HashMap保证线程安全

两种方法

1. 对所有HashMap的修改操作 加锁  `synchronized`
2. 使用ConcurrentHashMap

##  ConcurrentHashMap 与 HashTable 的区别

HashTable 对持有的 hash 结构进行整体加锁

ConcurrentHashMap 对持有的数据结构分段（segment），默认16段，对每段进行写加锁，提高了效率

简单说，ConcurrentHashMap达到了效率与线程安全的平衡

## Java里边有哪些锁 乐观锁悲观锁

**公平锁/非公平锁** 指线程是否按照申请顺序来获取锁 `synchronized` 是非公平锁

**独享锁/共享锁** 指该锁是否一次只能被一个线程持有 `synchronized` 是独享锁

**乐观锁/悲观锁** 看待并发同步的角度 

- 悲观锁 每次获取数据时都认为数据有可能被修改，因此上锁后才进行操作，其他线程想获取数据只能等该线程使用完后再去拿锁
- 乐观锁 读数据的时候不上锁，但是在更新的时候会加锁并判断期间数据有没有被其他线程修改，**适用于读操作较多的场合**（版本号机制）

## Java 设计模式 举例 

> 参阅资料

## 工作中有哪些印象深刻的用户反馈问题 

工作中碰到的CRM问题很多，大部分集中在兼容性、稳定性这些维度，还有一些后端接口导致的问题

- 本地数据库版本更新同步问题
- 登录鉴权失效，无法记住用户信息
- SP版本更新，本地缓存失效
- 第三方组件版本更新导致问题
- 后端接口变动导致前端出现问题