# 并发

[JavaGuide](https://snailclimb.gitee.io/javaguide/#/)

## 运行时内存结构

![Java运行时内存结构](https://upload-images.jianshu.io/upload_images/2184951-26a425725ca32aff.png)

![线程与进程](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.png)

**程序计数器** 每个线程都有自己的计数器
- 实现流程控制，如顺序执行、选择、循环等
- 记录当前线程执行的位置，切换线程使用

**虚拟机栈** 每个线程维护一个虚拟机栈，栈中的元素叫栈帧，栈帧中存放了方法的局部变量表、操作数栈、动态链接、返回信息，作用是**支持方法的调用和执行**

**本地方法栈** 与虚拟机栈很相似，唯一不同的是本地方法栈执行的是**Native方法**

> 上面的结构都是线程私有，生命周期跟线程生命周期一致

**堆** 所有线程共享的一块内存区域，在虚拟机（进程）启动时创建。**堆的作用是存放对象实例**，几乎所有的对象都将实例生成在堆中。Java堆中的实例都由GC（垃圾回收）算法进行管理

**方法区** 所有内存共享的一块内存区域，存储**被虚拟机加载的类信息、常量、静态变量、即时编译代码**等信息（永久代）

**运行时常量池** 方法区的一部分，除了类的描述信息，还有其他常量池信息，如字面量（文本字符串、声明为`final`的常量、基本数据类型的**值**等）符号引用

> JDK 1.7 之后，JVM将运行时常量池从方法区中移出来，单独开辟了一块内存作为运行时常量池

## Android 中常用的锁

常用来实现线程同步的锁 `synchronized` `Lock`

`synchronized` 常用方式 

- 对象锁 `synchronized(object)` 
- 方法锁 `synchronized(method)`
- 类锁 对静态方法加锁，概念上的东西，实际上因为静态类共享一个类对象，所以就是给静态类的`Class`对象加锁

`Lock` 是 Java 中的一个锁的接口，`synchronized` 是语言特性，可以用来替代`synchronized` 但是一定要手动释放锁



## 可见性/有序性/原子性

**可见性** 一个线程对共享变量做了修改之后，其他的线程立即能够看到（感知到）该变量这种修改。通过 `volatile` 修饰内存中的变量，**保证该变量在每次可用时的值都是最新的**，对多线程保持可见性

**原子性** 一个操作不能被打断，要么全部执行完毕，要么不执行。要想在多线程环境下保证原子性，则可以通过锁、`synchronized`来确保。`volatile`是无法保证复合操作的原子性，例如自增；使用`java.util.concurrent.atomic`能保证原子性 `AtomicInteger.incrementAndGet()`

**有序性**  在本线程内观察，操作都是有序的。`synchronized` 也就是对线程加锁，能保证本线程内有序