# 杂面试题

## 封装一个网络框架，需要考虑哪些问题

面向客户端

- 提供对请求体进行封装的能力，包装成需要的请求任务
- 提供回调接口，让响应体能被调用端获取到

面向服务端

- 需要维护一个线程池来管理所有封装过的请求体（主要）
- 同时有多个请求任务的情况，需要队列来管理，这时候可以使用`ThreadPoolExecutor` 
- 遇到断网等情况，需要维护一个请求任务的阻塞队列，可以实现重试机制

解析过程中

- 在请求和响应之间实现拦截机制，在切面上增加`cookie` `Authoration` 等
- 对响应实体的数据进行解析，使客户端能拿到直接可用的对象

## 单例模式

| 名称             | 延迟初始化 | 线程安全 |                                       |
| ---------------- | ---------- | -------- | ------------------------------------- |
| 非线程安全懒汉式 | 是         | 否       |                                       |
| 线程安全懒汉式   | 是         | 是       | 在获取实例方法上加锁，效率低          |
| 饿汉式           | 否         | 是       | 类加载时就初始化，浪费内存            |
| 双重校验锁       | 是         | 是       | `volatile` 修饰对象，对象锁，效率较高 |
| 静态内部类       | 是         | 是       | 这里的单例对象也是静态对象            |
| 枚举             | 否         | 是       |                                       |

 双重校验锁的单例模式需要在单例对象上加 `volatile` 关键字来避免线程获取不到单例对象的最新值

> `volatile` 被这个关键词修饰的变量能保证**每个线程获取到这个变量时，一定是该变量的最新值**

## 一个Android应用正常启动有多少个线程

主线程（UI线程）

GC守护线程（垃圾回收）

RenderThread（渲染线程 5.0 以后新增）

BinderThread 用于和 Service 通信

## Binder机制的实现思想

Linux 进程间通信的方法 管道 共享内存 Socket

Binder的优势 性能与安全综合下来比较好（管道两次拷贝，共享内存读写不够安全）

Binder被实现成为一个Linux的驱动，运行于内核态，通过内存映射（mmap），实现了一次拷贝

内存映射 将用户空间的一块内存区域映射到内核空间。映射关系建立后，用户对这块内存区域的修改可以直接反应到内核空间；反之内核空间对这段区域的修改也能直接反应到用户空间

## 有做过哪些优化工作，卡顿优化，内存优化，启动优化，APK体积优化，每个做了哪些工作

## JNI开发中有碰到什么问题？怎么定位native crash

## 你在项目中碰到什么比较棘手的问题？怎么解决的？

## 线程安全的观察者模式

使用`java.util.concurrent`包下的多线程同步工具

## Android 5.0 6.0 7.0 8.0 9.0 10.0 新特性

## ArrayMap和SparseArray原理

## 哪些场景会导致内存泄漏

https://blog.csdn.net/weixin_33743248/article/details/91424049

## ANR 定位和修正





