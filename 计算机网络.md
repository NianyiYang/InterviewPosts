# 计算机网络

## 网络体系结构

计算机网络层次结构模型和各层协议的集合，包括**开放系统互连参考模型OSI/RM**和TCP/IP参考模型，后者是事实上的标准模型

### OSI 7层模型

| 名称       | 传输介质         | 传输方式             | 作用                                      | 协议                |
| ---------- | ---------------- | -------------------- | ----------------------------------------- | ------------------- |
| 物理层     | 网线             | 比特流 Bit           | 提供物理连接                              |                     |
| 数据链路层 | 网卡/网桥/交换机 | 帧 Frame             | 为网络层提供**差错控制和流量控制**服务    | VLAN/MAC            |
| 网络层     | 路由器           | 数据报 Packet        | 解决路由选择/拥塞控制/多网络互联等问题    | IP/ARP              |
| 传输层     | --               | 数据段 Segment       | 提供端到端的服务，处理数据报错误/传输次序 | TCP/UDP             |
| 会话层     | --               | 会话协议数据单元SPDU | 建立/管理/终止会话                        | SSL/RPC             |
| 表示层     | --               | 表示协议数据单元PPDU | 对数据翻译/加密/压缩/解压                 | JPEG/XDP            |
| 应用层     | --               | 应用协议数据单元APDU | 各种应用程序服务                          | HTTP/FTP/SOCKET/DNS |

### TCP/IP 4层模型

| 名称                            | 传输方式  | 作用                   | 协议                  |
| ------------------------------- | --------- | ---------------------- | --------------------- |
| 网络接口层（物理层/数据链路层） | 比特流/帧 | 传输实际数据           | HDLC/PPP              |
| 网际层（网络层）                | 数据报    | 负责网络间寻址         | IP/ARP                |
| 传输层（传输层）                | 数据段    | 负责提供可靠的传输服务 | TCP/UDP               |
| 应用层                          | --        | 负责应用程序相关的功能 | HTTP/FTP/DNS/SMTP/SSL |

### 数据的包装

![Alt text](./0b7b02087bf40ad162f1b6beba9ee2dba8ecce89.jpeg)

---

## IP/TCP/UDP/HTTP 协议格式



### IP 协议格式

![img](https://img-blog.csdn.net/20170301092349308)

- **版本** IPv4 or IPv6

- **首部长度** 如果不要可变部分，固定长度为5 * 32bit 即 20个字节，可变长度最大为40字节

- **总长度** IP报文的总长度，理论最大值为 65535 字节，实际应用中受底层服务的最大传送单元（MTU）影响

- **标识** 数据报超过MTU大小，必须分片时，这个字段能标识分片位置，以便重新组装分片

- **标志** 表示分片与否以及是否为最后一片

- **片偏移** 表示本分片在原先数据报中相对首位的偏移

- **生存时间** IP报文允许通过路由器的最大数量，当该值为0时，路由器会丢弃该数据报

- **协议** 数据报携带的数据基于哪一种**传输层**协议，以便提交到对应的处理进程。TCP协议号6，UDP协议号17

- **首部校验和** 检查IP报头的完整性

- **源地址/目的地址** IP地址

### TCP协议格式

![img](https://farm1.staticflickr.com/792/27194088468_4cb0141fc8_b.jpg)

- 固定首部为20字节，可选长度最多为40字节
- **源端口** 源计算机发送该TCP数据段的端口号
- **目的端口** 目的计算机接受该TCP数据段的端口号
- **序号** 因为TCP协议是**面向连接**的协议，所以数据报文需要按照顺序编号
- **确认号** 如果目标主机正确接收到序号为X的TCP数据段，则该主机**会向源主机返回确认号X+1**
- **数据偏移** 因为首部有可选长度的关系，所以这里标识数据在报文段的起始偏移值
- 保留 保留字段，一般置0
- **控制位** 一共6个，每一个占一位，1表示有效，0表示无效
  - URG 紧急指针标志
  - ACK 确认序号标志
  - PSH Push标志，有效时表示接收方应该**尽快将报文提交给应用，而不是在缓冲区排队**
  - RST 重置链接标志，用于重置主机错误/拒绝非法报文/拒绝连接请求
  - SYN 同步序号，连接过程中使用（三次握手）
  - FIN 结束标志，表示发送方没有数据要发送了，关闭数据流
- **窗口** 滑动窗口大小，**告诉发送端，接收端的缓冲区大小**，流量控制
- **校验和** 对整个TCP数据段做**奇偶校验**，判断完整性。发送端计算，接收端验证
- **紧急指针** 当URG=1时有效。发送紧急数据时使用

> **注意：TCP报文段的数据部分是可选的**，建立连接和终止连接的TCP数据段**仅有首部**（因为只做连接确认）

  

 ### UDP协议格式

![img](http://c.biancheng.net/uploads/allimg/191111/6-1911111249535K.gif)

- 固定首部为8字节（注意：**没有可变首部**）
- **源端口** 源计算机发送该TCP数据段的端口号
- **目的端口** 目的计算机接受该TCP数据段的端口号
- **长度** UDP数据段的总长度，**包括UDP首部和数据长度**（所以最小长度为8字节）
- **校验值** 对整个UDP数据段做**奇偶校验**，判断完整性。发送端计算，接收端验证

> 可见UDP数据段只对数据做了校验，**而且是无连接的，不需要建立连接，也不需要保证可靠交付**
>
> 同样，因为没有窗口，所以也不做拥塞控制


### HTTP协议格式

HTTP报文分两种：请求报文和响应报文

#### 请求报文

![wKioL1MpX-qwK1-PAAExXPRpR8M814.jpg](https://s3.51cto.com/wyfs02/M02/22/DA/wKioL1MpX-qwK1-PAAExXPRpR8M814.jpg)

请求报文分为三大部分：请求行 请求头部 请求体（**其中请求头部和请求体中间有个空行**）

![这个图可能更清楚一点](https://img2018.cnblogs.com/blog/885859/201907/885859-20190724173242717-440362909.png)

> **因为是应用层协议，无法按位/字节来区分行数，所以每一行以回车+换行来区分**

- **方法** 标识该请求是什么方法，即 GET/POST/PUT/DELETE 等（严格大写）
- **URL** 统一资源定位符，通俗来说就是网站的链接
- **版本** 属于哪一版本的HTTP协议，如 HTTP/1.1 HTTP/1.0 等
- **请求头** 每行一对键值对，负责告知服务端某些额外信息
  - 通用头部：指请求报文和响应报文都支持的头部信息（列出常见的部分）
	    - **Cache-Control** 说明该请求/响应的缓存策略，如 `no-cache` `no-store` `only-if-cached` `max-age` 等
	    - **Connection** 表示该请求/响应的连接策略，如 `keep-alive` 表示持久连接`close` 表示连接结束就关闭TCP连接； 注意：如果HTTP协议版本为 HTTP/1.1，默认值为 `keep-alive` 
	    - Via 列出该请求/响应经过了那些代理服务器以及代理协议

  - 实体头部：描述实体属性时使用的头部，提供了有关实体及其内容的大量信息，从有关对象类型的信息，到能够对资源使用的各种有效的请求方法。**请求报文和响应报文都可以包含实体头部**，但是并不是像通用头部一样两种协议均支持（列出常见的部分）
	    - Allow 列出服务端支持的请求方法
	    - Content-Encoding 服务端使用的压缩方法，例如`gzip` `deflate`
	    - Content-Language：服务器告诉客户端应该采用的自然语言，例如中文，英文，日语等
	    - Content-Length：服务器端告诉客户端响应体的长度
	    - Content-Location：服务器端告诉客户端资源所在的实际位置
	    - Content-Range：在整个资源中此实体表示的字节范围
	    - Content-Type：请求或者响应的对象类型，例如`text/html` `image/png` `application/json` 等
	- 请求头部：指客户端告诉服务端自己支持的请求
		- **Accept** 指定客户端能够接收的内容类型
		- **Accept-Charset** 客户端可以接受的字符编码集
		- **Accept-Encoding**	客户端可以接受的压缩方法
		- **Accept-Language** 客户端可以接受的自然语言
		- **Accept-Ranges** 可以请求网页实体的一个或者多个子范围字段
		- **Authorization** 服务器授权必须的信息
		- **Cookie** HTTP请求发送时，会把保存在该请求域名下的所有 cookie 值一起发送给服务器。cookie 之间以 ; 间隔
		- **User-Agent** 客户端自身信息，表明自己是哪一种浏览器

#### 响应报文
![响应报文](https://s3.51cto.com/wyfs02/M02/22/DB/wKiom1MpmHWALc2UAADu14JLceA655.jpg)
响应报文分为三大部分：响应状态行 响应头部 响应体（**其中响应头部和响应体中间同样有个空行**）
- **版本** 属于哪一版本的HTTP协议，如 HTTP/1.1 HTTP/1.0 等
- **状态码** 表示响应目前是什么状态，例如`200` `404` `503` 等
- **原因短语** 对应响应状态码的原因短语，例如 `OK` `Not Found` `Service Unavailable` 等
- **响应头** 每行一对键值对，负责告知客户端某些额外信息，前面已经介绍了通用头部和实体头部，这里仅就部分响应头做下说明
	- Allow 服务器支持哪些请求方法
	- Set-Cookie 服务器在客户端第一次请求时将cookies发送给客户端

## 建立一次HTTP连接经历的过程

1. **输入网址** 输入需要访问的 url
2. **缓存解析** 如果没有禁止缓存，则浏览器先去检查缓存；如果有缓存，则从缓存中直接拿到页面并显示，负责继续下一步
3. **域名解析** 域名到IP地址的转换过程，由DNS服务器完成（从结点DNS服务器向上追溯到Root DNS服务器），解析结束后能获取IP地址
4. **TCP连接（三次握手）** 获得IP后，浏览器向服务端发起请求，会先建立一个TCP连接，成功后才进入下一步
5. **渲染页面** 获取服务端返回的响应报文，生成DOM树，解析css样式与js交互

### TCP建立连接（三次握手）
![三次握手](https://img-blog.csdn.net/20180717202520531?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTUwMzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

> 建立连接的TCP数据段都只有头部，没有实体部分

1. 客户端发送一个TCP数据段，生成一个随机的序号seq（该字段见TCP协议，占 4 个字节）X，并将标志位SYN设为1，表示是一次客户端向服务端连接确认的请求

> 第一次握手 客户端发送 SYN = 1 seq = X

2. 服务端收到该TCP数据段，由SYN=1知道这是客户端发送的连接请求，如果服务端提供服务，则会包装一个TCP数据段，其中SYN=1标识是建立连接，ACK=1表示是服务端已经收到客户端的连接请求的确认，生成确认号ack（**注意：确认号是返回的序号seq加一**）X+1，自己也生成一个新的序号seq = Y，发送给客户端

> 第二次握手 服务端发送 SYN=1 ACK=1 seq=Y ack=X+1

3. 客户端收到数据段，检查 ack 是否等于X+1，以及ACK=1，如果正确，则会包装一个TCP数据段，将ACK设为1（**不用设置SYN**），并返回确认号ack=Y+1，序号依然为seq=X+1，并将客户端置为`ESTABLISHED` 状态

> 第三次握手 客户端发送 ACK=1 seq=X+1 ack=Y+1

4. 服务端收到连接确认，也将自己置为`ESTABLISHED`状态，客户端与服务端完成三次握手

### TCP断开连接（四次挥手）
![四次挥手](https://img-blog.csdn.net/20180717204202563?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTUwMzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

> 与建立连接一样，断开连接也是客户端发起

1. 客户端发送一个TCP数据段，生成一个序号seq（该字段见TCP协议，占 4 个字节）X，**X是前一个已接收数据的序号加一**，并将标志位FIN设为1，表示是一次客户端向服务端发送断开连接的请求。此时客户端进入『中止等待』的状态
2. 服务端收到断开连接的请求，则向客户端发送断开确认的数据段，ACK=1，确认号ack=X，并且生成序号seq=Y。**此时如果服务端还有数据需要发送，则继续向客户端发送数据，客户端此时仍然需要接收服务端传来的数据**
3. 服务端发送完最后的数据后，就向客户端发送连接释放数据段，FIN=1，ack=X+1，seq=Z，并等待客户端确认
4. 客户端收到服务端的数据段，发出确认，ACK=1，seq=X+1，ack=Z+1。此时，**客户端进入时间等待状态，必须经过两倍的最长报文段寿命（来回）之后，才真正释放连接**
5. 服务端收到客户端的数据段后，立即释放连接



## HTTPS相关

HTTP 协议是**无状态的**，比如每次都要调用登录接口；本身是**无连接的**（HTTP/1.1）（依赖的传输层TCP协议是面向连接），而且**明文传输数据**，不会确认数据的完整性

HTTPS 协议，即**超文本传输安全协议**，常称为 HTTP over SSL/TLS，是一种能进行安全通信的应用层传输协议，本身**基于HTTP协议进行数据传输，通过SSL协议提供加解密/身份验证/数据完整性检测等服务**



### 加密算法

数据加密就是**对原来的明文文件/数据通过某种算法处理后变成密文，并能在输入对应密钥的情况下还原成明文**的过程

> 因为 `MD5` 算法是一种**哈希算法，是不可逆的**，只能将明文转化为密文，无法还原成明文，因此不能算严格意义上的加密算法（有些人也将这类散列算法称为加密算法）

**对称加密** 又称共享密钥加密算法，加密和解密用的是**同一个密钥**，有`DES` `3DES` `AES` 等

**非对称加密** 又称公开密钥加密算法，需要两个密钥，一个叫**公钥**，一个叫**私钥**，加密和解密用不同的密钥，常见算法有`RSA` `DSA`等；公钥和私钥不一定必须对应加密和解密：如果使用 **公钥** 对数据 **进行加密**，只有用对应的 **私钥** 才能 **进行解密**；如果使用 **私钥** 对数据 **进行加密**，只有用对应的 **公钥** 才能 **进行解密**

两种加密方式的比较

- 对称加密比非对称加密快很多倍（数量级差距），可用来对大量数据进行加密解密
- 对称加密的安全性没有非对称加密高（很显然），因此非对称加密可用来进行数字签名
- 在密钥管理上，对称加密需要告诉接收方密钥，不便于管理；非对称加密只需要发布公钥即可



### HTTPS协议运行过程

![img](https://img-blog.csdn.net/20160818103824711?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

1. 客户端发起HTTPS请求，希望连接到服务器的443端口
2. 服务端接收到客户端请求，并将公钥发送给客户端
3. 客户端收到服务端的公钥后（一般是SSL证书），会验证合法性，如果公钥合格，那么客户端**会生成一个用于对称加密的密钥，并将该密钥使用服务器端给的公钥加密后**发送给服务器
4. 服务端收到客户端的数据段，用自己的私钥解密，得到客户端对称加密的密钥
5. 此后服务端与客户端均可对传输数据进行对称加密解密传输

> Tips
>
> 发起HTTPS请求是**基于TCP连接建立完成**的基础上，所以三次握手在上面的第一步之前就完成了
>
> 在**建立连接阶段使用非对称加密，在数据传输过程中使用对称加密**，这是由两种加密的特点决定的
>
> 对称加密的密钥是在建立连接的过程中通过非对称加密加密后传给服务端的



